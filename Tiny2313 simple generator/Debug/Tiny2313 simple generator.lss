
Tiny2313 simple generator.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000592  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000606  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001e  00800060  00800060  00000606  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000606  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000638  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000058  00000000  00000000  00000678  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000046b  00000000  00000000  000006d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000011c  00000000  00000000  00000b3b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000055a  00000000  00000000  00000c57  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000e4  00000000  00000000  000011b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000016f  00000000  00000000  00001298  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000069  00000000  00000000  00001407  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000118  00000000  00000000  00001470  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	1f c0       	rjmp	.+62     	; 0x42 <__bad_interrupt>
   4:	1e c0       	rjmp	.+60     	; 0x42 <__bad_interrupt>
   6:	1d c0       	rjmp	.+58     	; 0x42 <__bad_interrupt>
   8:	42 c0       	rjmp	.+132    	; 0x8e <__vector_4>
   a:	1b c0       	rjmp	.+54     	; 0x42 <__bad_interrupt>
   c:	1a c0       	rjmp	.+52     	; 0x42 <__bad_interrupt>
   e:	19 c0       	rjmp	.+50     	; 0x42 <__bad_interrupt>
  10:	18 c0       	rjmp	.+48     	; 0x42 <__bad_interrupt>
  12:	17 c0       	rjmp	.+46     	; 0x42 <__bad_interrupt>
  14:	16 c0       	rjmp	.+44     	; 0x42 <__bad_interrupt>
  16:	15 c0       	rjmp	.+42     	; 0x42 <__bad_interrupt>
  18:	14 c0       	rjmp	.+40     	; 0x42 <__bad_interrupt>
  1a:	14 c0       	rjmp	.+40     	; 0x44 <__vector_13>
  1c:	12 c0       	rjmp	.+36     	; 0x42 <__bad_interrupt>
  1e:	11 c0       	rjmp	.+34     	; 0x42 <__bad_interrupt>
  20:	10 c0       	rjmp	.+32     	; 0x42 <__bad_interrupt>
  22:	0f c0       	rjmp	.+30     	; 0x42 <__bad_interrupt>
  24:	0e c0       	rjmp	.+28     	; 0x42 <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf ed       	ldi	r28, 0xDF	; 223
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_clear_bss>:
  2e:	20 e0       	ldi	r18, 0x00	; 0
  30:	a0 e6       	ldi	r26, 0x60	; 96
  32:	b0 e0       	ldi	r27, 0x00	; 0
  34:	01 c0       	rjmp	.+2      	; 0x38 <.do_clear_bss_start>

00000036 <.do_clear_bss_loop>:
  36:	1d 92       	st	X+, r1

00000038 <.do_clear_bss_start>:
  38:	ae 37       	cpi	r26, 0x7E	; 126
  3a:	b2 07       	cpc	r27, r18
  3c:	e1 f7       	brne	.-8      	; 0x36 <.do_clear_bss_loop>
  3e:	31 d0       	rcall	.+98     	; 0xa2 <main>
  40:	a6 c2       	rjmp	.+1356   	; 0x58e <_exit>

00000042 <__bad_interrupt>:
  42:	de cf       	rjmp	.-68     	; 0x0 <__vectors>

00000044 <__vector_13>:
{
	uint32_t m;

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
	{
		m = st_timer0_millis;
  44:	1f 92       	push	r1
  46:	0f 92       	push	r0
  48:	0f b6       	in	r0, 0x3f	; 63
  4a:	0f 92       	push	r0
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
  4c:	11 24       	eor	r1, r1
PT_THREAD(Switch(struct pt *pt))
{
	//uint32_t dur=0;
	static volatile uint32_t switch_timer=0;
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-switch_timer)>=10);//запуск протопотока каждые 10мсек
  4e:	8f 93       	push	r24
  50:	9f 93       	push	r25
  52:	af 93       	push	r26
  54:	bf 93       	push	r27
  56:	80 91 6e 00 	lds	r24, 0x006E
  5a:	90 91 6f 00 	lds	r25, 0x006F
  5e:	a0 91 70 00 	lds	r26, 0x0070
  62:	b0 91 71 00 	lds	r27, 0x0071
  66:	01 96       	adiw	r24, 0x01	; 1
  68:	a1 1d       	adc	r26, r1
  6a:	b1 1d       	adc	r27, r1
  6c:	80 93 6e 00 	sts	0x006E, r24
  70:	90 93 6f 00 	sts	0x006F, r25
		//Макс частота нажатия кнопки ~2Гц
		LED0_OFF;
		LED1_OFF;
	}
	PT_END(pt);
}
  74:	a0 93 70 00 	sts	0x0070, r26
//Фукция выдачи текущего системного времени
uint32_t st_millis(void)
{
	uint32_t m;

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
  78:	b0 93 71 00 	sts	0x0071, r27
	{
		m = st_timer0_millis;
  7c:	bf 91       	pop	r27
  7e:	af 91       	pop	r26
  80:	9f 91       	pop	r25
  82:	8f 91       	pop	r24
  84:	0f 90       	pop	r0
  86:	0f be       	out	0x3f, r0	; 63
  88:	0f 90       	pop	r0
  8a:	1f 90       	pop	r1
  8c:	18 95       	reti

0000008e <__vector_4>:
{
	//uint32_t dur=0;
	static volatile uint32_t switch_timer=0;
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-switch_timer)>=10);//запуск протопотока каждые 10мсек
	switch_timer=st_millis();
  8e:	1f 92       	push	r1
  90:	0f 92       	push	r0
  92:	0f b6       	in	r0, 0x3f	; 63
  94:	0f 92       	push	r0
  96:	11 24       	eor	r1, r1
  98:	0f 90       	pop	r0
  9a:	0f be       	out	0x3f, r0	; 63
  9c:	0f 90       	pop	r0
	if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->state==GEN_OFF))
  9e:	1f 90       	pop	r1
  a0:	18 95       	reti

000000a2 <main>:
  a2:	10 92 7a 00 	sts	0x007A, r1
		}
		p_generator->state=GEN_ON;
		CONNECT_TIMER_TO_PIN;//подключаем таймер к пину
		GENERATOR_ON;
	}
	else if (p_generator->regime==GEN_UART)
  a6:	10 92 7b 00 	sts	0x007B, r1
  aa:	10 92 7c 00 	sts	0x007C, r1
	{
		//тут что-то будет :) можно прямо здесь написать работу от уарта, а можно в отдельно протопотоке
	}
	else 
	{
		GENERATOR_OFF;
  ae:	10 92 7d 00 	sts	0x007D, r1
		DISCONETC_TIMER_FROM_PIN;//Отключаем OC1A от PB3, включаем управление GPIO
  b2:	8e e1       	ldi	r24, 0x1E	; 30
  b4:	81 bb       	out	0x11, r24	; 17
  b6:	8f ef       	ldi	r24, 0xFF	; 255
		//p_generator->regime=GEN_MANUAL; //на всякий пожарный, если режим генератора свалится в что-то неизвестное,
		//то попадет сюда и выставит ручной режим
		p_generator->state=GEN_ON;
  b8:	87 bb       	out	0x17, r24	; 23
  ba:	80 e6       	ldi	r24, 0x60	; 96
  bc:	82 bb       	out	0x12, r24	; 18
		PT_SPAWN(pt, &Sync_pt, Sync(&Sync_pt));//вызываем дочерний протопоток ручного или синхро запуска
  be:	18 ba       	out	0x18, r1	; 24
  c0:	82 e0       	ldi	r24, 0x02	; 2
  c2:	80 bf       	out	0x30, r24	; 48
  c4:	83 e0       	ldi	r24, 0x03	; 3
  c6:	83 bf       	out	0x33, r24	; 51
  c8:	12 be       	out	0x32, r1	; 50
  ca:	8d e7       	ldi	r24, 0x7D	; 125
  cc:	86 bf       	out	0x36, r24	; 54
  ce:	82 e8       	ldi	r24, 0x82	; 130
/* Протопотоки */

//Дочерний протопоток, который отрабатывает ручной запуск
PT_THREAD(Sync(struct pt *pt))
{
	PT_BEGIN(pt);
  d0:	8f bd       	out	0x2f, r24	; 47
  d2:	8c e1       	ldi	r24, 0x1C	; 28
  d4:	8e bd       	out	0x2e, r24	; 46
  d6:	1d bc       	out	0x2d, r1	; 45
  d8:	1c bc       	out	0x2c, r1	; 44
  da:	89 b7       	in	r24, 0x39	; 57
		OUT_OFF; //сбрасываем выход в 0
		_delay_ms(500); //задержка перед следующим срабатыванием
		LED0_OFF;
	}
	PT_EXIT(pt);
	PT_END(pt);
  dc:	81 60       	ori	r24, 0x01	; 1
  de:	89 bf       	out	0x39, r24	; 57
  e0:	10 92 79 00 	sts	0x0079, r1
		//p_generator->regime=GEN_MANUAL; //на всякий пожарный, если режим генератора свалится в что-то неизвестное,
		//то попадет сюда и выставит ручной режим
		p_generator->state=GEN_ON;
		PT_SPAWN(pt, &Sync_pt, Sync(&Sync_pt));//вызываем дочерний протопоток ручного или синхро запуска
		//Макс частота нажатия кнопки ~2Гц
		LED0_OFF;
  e4:	10 92 78 00 	sts	0x0078, r1
		LED1_OFF;
  e8:	10 92 77 00 	sts	0x0077, r1
PT_THREAD(Sync(struct pt *pt))
{
	PT_BEGIN(pt);
	//PT_SEM_SIGNAL(pt, &manual_pulse); //устанавливает 1 в manual_pulse, сигнализируя что кнопки больше не опрашивались в другом пропотоке
	OUT_OFF; //устанавливаем 0 на выходе
	if (!(BUT0_PORT_PIN&(_BV(BUT0))))//((BUT0_PORT_PIN&(_BV(BUT0)))==0)
  ec:	10 92 76 00 	sts	0x0076, r1
	{
		LED0_ON;
  f0:	10 92 75 00 	sts	0x0075, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  f4:	10 92 74 00 	sts	0x0074, r1
  f8:	10 92 73 00 	sts	0x0073, r1
		OUT_ON; //устанавливаем 1 на выходе
		_delay_us(5); //держим 1 на пине 80 микросекунд
		OUT_OFF; //сбрасываем выход в 0
  fc:	10 92 72 00 	sts	0x0072, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 100:	a8 95       	wdr
 102:	9f e0       	ldi	r25, 0x0F	; 15
 104:	88 e1       	ldi	r24, 0x18	; 24
 106:	0f b6       	in	r0, 0x3f	; 63
 108:	f8 94       	cli
 10a:	a8 95       	wdr
 10c:	81 bd       	out	0x21, r24	; 33
 10e:	0f be       	out	0x3f, r0	; 63
		_delay_ms(500); //задержка перед следующим срабатыванием
		LED0_OFF;
 110:	91 bd       	out	0x21, r25	; 33
 112:	78 94       	sei
	//uint32_t dur=0;
	static volatile uint32_t switch_timer=0;
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-switch_timer)>=10);//запуск протопотока каждые 10мсек
	switch_timer=st_millis();
	if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->state==GEN_OFF))
 114:	22 e0       	ldi	r18, 0x02	; 2
 116:	a2 2e       	mov	r10, r18
 118:	bb 24       	eor	r11, r11
 11a:	b3 94       	inc	r11
	{
		CLEAR_TCCR1B;
 11c:	48 ef       	ldi	r20, 0xF8	; 248
 11e:	50 e0       	ldi	r21, 0x00	; 0
 120:	e3 e6       	ldi	r30, 0x63	; 99
		if (p_generator->period==PERIOD_HZ1000)
 122:	f1 e0       	ldi	r31, 0x01	; 1
 124:	02 e1       	ldi	r16, 0x12	; 18
		{
			TCCR1B|=PRESCALER_1_MASK;
 126:	1a e7       	ldi	r17, 0x7A	; 122
	PT_WAIT_UNTIL(pt,(st_millis()-switch_timer)>=10);//запуск протопотока каждые 10мсек
	switch_timer=st_millis();
	if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->state==GEN_OFF))
	{
		CLEAR_TCCR1B;
		if (p_generator->period==PERIOD_HZ1000)
 128:	c0 e1       	ldi	r28, 0x10	; 16
 12a:	d7 e2       	ldi	r29, 0x27	; 39
		{
			TCCR1B|=PRESCALER_1_MASK;
			ICR1=PERIOD_HZ1000_TICKS;
		}
		else if (p_generator->period==PERIOD_HZ100)
 12c:	69 e2       	ldi	r22, 0x29	; 41
 12e:	71 e0       	ldi	r23, 0x01	; 1
 130:	2f e6       	ldi	r18, 0x6F	; 111
			TCCR1B|=PRESCALER_8_MASK;
			ICR1=PERIOD_HZ100_TICKS;
		}
		else 
		{
			TCCR1B|=PRESCALER_256_MASK;
 132:	31 e0       	ldi	r19, 0x01	; 1
 134:	2c c0       	rjmp	.+88     	; 0x18e <__stack+0xaf>
			ICR1=PERIOD_HZ1_TICKS;
 136:	88 3f       	cpi	r24, 0xF8	; 248
 138:	91 05       	cpc	r25, r1
 13a:	99 f1       	breq	.+102    	; 0x1a2 <__stack+0xc3>
 13c:	10 92 79 00 	sts	0x0079, r1
		}
		if (p_generator->duration==DURATION_90)
 140:	10 92 78 00 	sts	0x0078, r1
 144:	80 91 76 00 	lds	r24, 0x0076
		{
			OCR1=(uint16_t)((7*(uint32_t)ICR1)>>3);
		}
		else if (p_generator->duration==DURATION_50)
 148:	90 91 77 00 	lds	r25, 0x0077
		{
			OCR1=(uint16_t)((uint32_t)ICR1>>1);
		}
		else
		{
			if (p_generator->period==PERIOD_HZ1000)
 14c:	89 32       	cpi	r24, 0x29	; 41
 14e:	a1 e0       	ldi	r26, 0x01	; 1
 150:	9a 07       	cpc	r25, r26
			{
				OCR1=(uint16_t)(5*(uint32_t)ICR1>>4);
			}
			else if (p_generator->period==PERIOD_HZ100)
 152:	09 f4       	brne	.+2      	; 0x156 <__stack+0x77>
 154:	bc c0       	rjmp	.+376    	; 0x2ce <__stack+0x1ef>
 156:	83 36       	cpi	r24, 0x63	; 99
			{
				OCR1=(uint16_t)((uint32_t)ICR1>>5);
			}
			else
			{
				OCR1=(uint16_t)(5*(uint32_t)ICR1>>14);
 158:	b1 e0       	ldi	r27, 0x01	; 1
 15a:	9b 07       	cpc	r25, r27
 15c:	09 f4       	brne	.+2      	; 0x160 <__stack+0x81>
 15e:	1b c1       	rjmp	.+566    	; 0x396 <__stack+0x2b7>
 160:	89 2b       	or	r24, r25
 162:	09 f4       	brne	.+2      	; 0x166 <__stack+0x87>
 164:	b0 c0       	rjmp	.+352    	; 0x2c6 <__stack+0x1e7>
 166:	10 92 77 00 	sts	0x0077, r1
 16a:	10 92 76 00 	sts	0x0076, r1
 16e:	80 91 74 00 	lds	r24, 0x0074
 172:	90 91 75 00 	lds	r25, 0x0075
 176:	00 97       	sbiw	r24, 0x00	; 0
 178:	09 f4       	brne	.+2      	; 0x17c <__stack+0x9d>
 17a:	61 c0       	rjmp	.+194    	; 0x23e <__stack+0x15f>
 17c:	8f 36       	cpi	r24, 0x6F	; 111
 17e:	91 40       	sbci	r25, 0x01	; 1
 180:	09 f4       	brne	.+2      	; 0x184 <__stack+0xa5>
 182:	61 c0       	rjmp	.+194    	; 0x246 <__stack+0x167>
 184:	10 92 75 00 	sts	0x0075, r1
 188:	10 92 74 00 	sts	0x0074, r1
 18c:	a8 95       	wdr
			}
		}
		p_generator->state=GEN_ON;
 18e:	80 91 78 00 	lds	r24, 0x0078
 192:	90 91 79 00 	lds	r25, 0x0079
		CONNECT_TIMER_TO_PIN;//подключаем таймер к пину
 196:	00 97       	sbiw	r24, 0x00	; 0
 198:	71 f6       	brne	.-100    	; 0x136 <__stack+0x57>
		GENERATOR_ON;
 19a:	50 93 79 00 	sts	0x0079, r21
 19e:	40 93 78 00 	sts	0x0078, r20
	if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->state==GEN_OFF))
	{
		CLEAR_TCCR1B;
		if (p_generator->period==PERIOD_HZ1000)
		{
			TCCR1B|=PRESCALER_1_MASK;
 1a2:	8f b7       	in	r24, 0x3f	; 63
 1a4:	f8 94       	cli
			ICR1=PERIOD_HZ1000_TICKS;
 1a6:	c0 90 6e 00 	lds	r12, 0x006E
 1aa:	d0 90 6f 00 	lds	r13, 0x006F
 1ae:	e0 90 70 00 	lds	r14, 0x0070
			TCCR1B|=PRESCALER_256_MASK;
			ICR1=PERIOD_HZ1_TICKS;
		}
		if (p_generator->duration==DURATION_90)
		{
			OCR1=(uint16_t)((7*(uint32_t)ICR1)>>3);
 1b2:	f0 90 71 00 	lds	r15, 0x0071
 1b6:	8f bf       	out	0x3f, r24	; 63
 1b8:	40 90 6a 00 	lds	r4, 0x006A
 1bc:	50 90 6b 00 	lds	r5, 0x006B
 1c0:	60 90 6c 00 	lds	r6, 0x006C
 1c4:	70 90 6d 00 	lds	r7, 0x006D
 1c8:	c4 18       	sub	r12, r4
 1ca:	d5 08       	sbc	r13, r5
 1cc:	e6 08       	sbc	r14, r6
 1ce:	f7 08       	sbc	r15, r7
 1d0:	88 e7       	ldi	r24, 0x78	; 120
 1d2:	c8 16       	cp	r12, r24
 1d4:	d1 04       	cpc	r13, r1
 1d6:	e1 04       	cpc	r14, r1
 1d8:	f1 04       	cpc	r15, r1
 1da:	08 f4       	brcc	.+2      	; 0x1de <__stack+0xff>
 1dc:	b3 cf       	rjmp	.-154    	; 0x144 <__stack+0x65>
 1de:	8f b7       	in	r24, 0x3f	; 63
 1e0:	f8 94       	cli
 1e2:	c0 90 6e 00 	lds	r12, 0x006E
 1e6:	d0 90 6f 00 	lds	r13, 0x006F
 1ea:	e0 90 70 00 	lds	r14, 0x0070
 1ee:	f0 90 71 00 	lds	r15, 0x0071
			TCCR1B|=PRESCALER_1_MASK;
			ICR1=PERIOD_HZ1000_TICKS;
		}
		else if (p_generator->period==PERIOD_HZ100)
		{
			TCCR1B|=PRESCALER_8_MASK;
 1f2:	8f bf       	out	0x3f, r24	; 63
			ICR1=PERIOD_HZ100_TICKS;
 1f4:	c0 92 6a 00 	sts	0x006A, r12
 1f8:	d0 92 6b 00 	sts	0x006B, r13
 1fc:	e0 92 6c 00 	sts	0x006C, r14
		{
			OCR1=(uint16_t)((7*(uint32_t)ICR1)>>3);
		}
		else if (p_generator->duration==DURATION_50)
		{
			OCR1=(uint16_t)((uint32_t)ICR1>>1);
 200:	f0 92 6d 00 	sts	0x006D, r15
 204:	85 99       	sbic	0x10, 5	; 16
 206:	0d c0       	rjmp	.+26     	; 0x222 <__stack+0x143>
 208:	80 91 7b 00 	lds	r24, 0x007B
			{
				OCR1=(uint16_t)(5*(uint32_t)ICR1>>4);
			}
			else if (p_generator->period==PERIOD_HZ100)
			{
				OCR1=(uint16_t)((uint32_t)ICR1>>5);
 20c:	81 11       	cpse	r24, r1
 20e:	d7 c0       	rjmp	.+430    	; 0x3be <__stack+0x2df>
 210:	b0 92 7b 00 	sts	0x007B, r11
 214:	10 92 7d 00 	sts	0x007D, r1
 218:	10 92 7a 00 	sts	0x007A, r1
 21c:	89 b7       	in	r24, 0x39	; 57
 21e:	8f 7b       	andi	r24, 0xBF	; 191
 220:	89 bf       	out	0x39, r24	; 57
 222:	86 99       	sbic	0x10, 6	; 16
 224:	8b cf       	rjmp	.-234    	; 0x13c <__stack+0x5d>
		}
		else
		{
			if (p_generator->period==PERIOD_HZ1000)
			{
				OCR1=(uint16_t)(5*(uint32_t)ICR1>>4);
 226:	80 91 7c 00 	lds	r24, 0x007C
 22a:	81 11       	cpse	r24, r1
 22c:	d2 c0       	rjmp	.+420    	; 0x3d2 <__stack+0x2f3>
 22e:	b0 92 7c 00 	sts	0x007C, r11
 232:	10 92 7a 00 	sts	0x007A, r1
 236:	89 b7       	in	r24, 0x39	; 57
 238:	8f 7b       	andi	r24, 0xBF	; 191
 23a:	89 bf       	out	0x39, r24	; 57
 23c:	7f cf       	rjmp	.-258    	; 0x13c <__stack+0x5d>
 23e:	30 93 75 00 	sts	0x0075, r19
 242:	20 93 74 00 	sts	0x0074, r18
 246:	8f b7       	in	r24, 0x3f	; 63
 248:	f8 94       	cli
 24a:	c0 90 6e 00 	lds	r12, 0x006E
 24e:	d0 90 6f 00 	lds	r13, 0x006F
 252:	e0 90 70 00 	lds	r14, 0x0070
 256:	f0 90 71 00 	lds	r15, 0x0071
 25a:	8f bf       	out	0x3f, r24	; 63
 25c:	40 90 62 00 	lds	r4, 0x0062
PT_THREAD(Leds(struct pt *pt))
{
	static volatile uint32_t leds_timer=0;
	static volatile uint8_t counter1, counter2=0;
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-leds_timer)>=100);//запуск протопотока каждые 0.1мсек
 260:	50 90 63 00 	lds	r5, 0x0063
 264:	60 90 64 00 	lds	r6, 0x0064
 268:	70 90 65 00 	lds	r7, 0x0065
 26c:	c4 18       	sub	r12, r4
 26e:	d5 08       	sbc	r13, r5
 270:	e6 08       	sbc	r14, r6
 272:	f7 08       	sbc	r15, r7
 274:	84 e6       	ldi	r24, 0x64	; 100
 276:	c8 16       	cp	r12, r24
 278:	d1 04       	cpc	r13, r1
 27a:	e1 04       	cpc	r14, r1
 27c:	f1 04       	cpc	r15, r1
 27e:	08 f4       	brcc	.+2      	; 0x282 <__stack+0x1a3>
 280:	85 cf       	rjmp	.-246    	; 0x18c <__stack+0xad>
//Фукция выдачи текущего системного времени
uint32_t st_millis(void)
{
	uint32_t m;

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 282:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 284:	f8 94       	cli
	{
		m = st_timer0_millis;
 286:	c0 90 6e 00 	lds	r12, 0x006E
 28a:	d0 90 6f 00 	lds	r13, 0x006F
 28e:	e0 90 70 00 	lds	r14, 0x0070
 292:	f0 90 71 00 	lds	r15, 0x0071
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 296:	8f bf       	out	0x3f, r24	; 63
{
	static volatile uint32_t leds_timer=0;
	static volatile uint8_t counter1, counter2=0;
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-leds_timer)>=100);//запуск протопотока каждые 0.1мсек
	leds_timer=st_millis();
 298:	c0 92 62 00 	sts	0x0062, r12
 29c:	d0 92 63 00 	sts	0x0063, r13
 2a0:	e0 92 64 00 	sts	0x0064, r14
 2a4:	f0 92 65 00 	sts	0x0065, r15
	if (p_generator->regime==GEN_PERIODIC)
 2a8:	80 91 7b 00 	lds	r24, 0x007B
 2ac:	81 30       	cpi	r24, 0x01	; 1
 2ae:	09 f4       	brne	.+2      	; 0x2b2 <__stack+0x1d3>
 2b0:	79 c0       	rjmp	.+242    	; 0x3a4 <__stack+0x2c5>
				LED1_OFF;
				break;
			}
		}
	}
	else if (p_generator->regime==GEN_UART) //моргаем обоими светодиодами
 2b2:	82 30       	cpi	r24, 0x02	; 2
 2b4:	19 f0       	breq	.+6      	; 0x2bc <__stack+0x1dd>
			LED1_ON;
		}
	}
	else
	{
		LED0_OFF;
 2b6:	93 98       	cbi	0x12, 3	; 18
		LED1_OFF;	
 2b8:	94 98       	cbi	0x12, 4	; 18
 2ba:	64 cf       	rjmp	.-312    	; 0x184 <__stack+0xa5>
			}
		}
	}
	else if (p_generator->regime==GEN_UART) //моргаем обоими светодиодами
	{
		if ((LED0_PORT_PIN&(_BV(LED0)))==0)
 2bc:	83 9b       	sbis	0x10, 3	; 16
 2be:	fb cf       	rjmp	.-10     	; 0x2b6 <__stack+0x1d7>
			LED0_OFF;
			LED1_OFF;
		}
		else 
		{
			LED0_ON;
 2c0:	93 9a       	sbi	0x12, 3	; 18
			LED1_ON;
 2c2:	94 9a       	sbi	0x12, 4	; 18
 2c4:	5f cf       	rjmp	.-322    	; 0x184 <__stack+0xa5>
PT_THREAD(Switch(struct pt *pt))
{
	//uint32_t dur=0;
	static volatile uint32_t switch_timer=0;
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-switch_timer)>=10);//запуск протопотока каждые 10мсек
 2c6:	70 93 77 00 	sts	0x0077, r23
 2ca:	60 93 76 00 	sts	0x0076, r22
//Фукция выдачи текущего системного времени
uint32_t st_millis(void)
{
	uint32_t m;

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 2ce:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 2d0:	f8 94       	cli
	{
		m = st_timer0_millis;
 2d2:	c0 90 6e 00 	lds	r12, 0x006E
 2d6:	d0 90 6f 00 	lds	r13, 0x006F
 2da:	e0 90 70 00 	lds	r14, 0x0070
 2de:	f0 90 71 00 	lds	r15, 0x0071
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 2e2:	8f bf       	out	0x3f, r24	; 63
PT_THREAD(Switch(struct pt *pt))
{
	//uint32_t dur=0;
	static volatile uint32_t switch_timer=0;
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-switch_timer)>=10);//запуск протопотока каждые 10мсек
 2e4:	40 90 66 00 	lds	r4, 0x0066
 2e8:	50 90 67 00 	lds	r5, 0x0067
 2ec:	60 90 68 00 	lds	r6, 0x0068
 2f0:	70 90 69 00 	lds	r7, 0x0069
 2f4:	c4 18       	sub	r12, r4
 2f6:	d5 08       	sbc	r13, r5
 2f8:	e6 08       	sbc	r14, r6
 2fa:	f7 08       	sbc	r15, r7
 2fc:	8a e0       	ldi	r24, 0x0A	; 10
 2fe:	c8 16       	cp	r12, r24
 300:	d1 04       	cpc	r13, r1
 302:	e1 04       	cpc	r14, r1
 304:	f1 04       	cpc	r15, r1
 306:	08 f4       	brcc	.+2      	; 0x30a <__stack+0x22b>
 308:	32 cf       	rjmp	.-412    	; 0x16e <__stack+0x8f>
//Фукция выдачи текущего системного времени
uint32_t st_millis(void)
{
	uint32_t m;

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 30a:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 30c:	f8 94       	cli
	{
		m = st_timer0_millis;
 30e:	c0 90 6e 00 	lds	r12, 0x006E
 312:	d0 90 6f 00 	lds	r13, 0x006F
 316:	e0 90 70 00 	lds	r14, 0x0070
 31a:	f0 90 71 00 	lds	r15, 0x0071
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 31e:	8f bf       	out	0x3f, r24	; 63
{
	//uint32_t dur=0;
	static volatile uint32_t switch_timer=0;
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-switch_timer)>=10);//запуск протопотока каждые 10мсек
	switch_timer=st_millis();
 320:	c0 92 66 00 	sts	0x0066, r12
 324:	d0 92 67 00 	sts	0x0067, r13
 328:	e0 92 68 00 	sts	0x0068, r14
 32c:	f0 92 69 00 	sts	0x0069, r15
	if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->state==GEN_OFF))
 330:	80 91 7b 00 	lds	r24, 0x007B
 334:	81 30       	cpi	r24, 0x01	; 1
 336:	09 f4       	brne	.+2      	; 0x33a <__stack+0x25b>
 338:	52 c0       	rjmp	.+164    	; 0x3de <__stack+0x2ff>
		}
		p_generator->state=GEN_ON;
		CONNECT_TIMER_TO_PIN;//подключаем таймер к пину
		GENERATOR_ON;
	}
	else if (p_generator->regime==GEN_UART)
 33a:	82 30       	cpi	r24, 0x02	; 2
 33c:	09 f4       	brne	.+2      	; 0x340 <__stack+0x261>
 33e:	13 cf       	rjmp	.-474    	; 0x166 <__stack+0x87>
	{
		//тут что-то будет :) можно прямо здесь написать работу от уарта, а можно в отдельно протопотоке
	}
	else 
	{
		GENERATOR_OFF;
 340:	89 b7       	in	r24, 0x39	; 57
 342:	8f 7b       	andi	r24, 0xBF	; 191
 344:	89 bf       	out	0x39, r24	; 57
		DISCONETC_TIMER_FROM_PIN;//Отключаем OC1A от PB3, включаем управление GPIO
 346:	8f b5       	in	r24, 0x2f	; 47
 348:	8f 77       	andi	r24, 0x7F	; 127
 34a:	8f bd       	out	0x2f, r24	; 47
		//p_generator->regime=GEN_MANUAL; //на всякий пожарный, если режим генератора свалится в что-то неизвестное,
		//то попадет сюда и выставит ручной режим
		p_generator->state=GEN_ON;
 34c:	b0 92 7a 00 	sts	0x007A, r11
		PT_SPAWN(pt, &Sync_pt, Sync(&Sync_pt));//вызываем дочерний протопоток ручного или синхро запуска
 350:	10 92 73 00 	sts	0x0073, r1
 354:	10 92 72 00 	sts	0x0072, r1
 358:	f0 93 77 00 	sts	0x0077, r31
 35c:	e0 93 76 00 	sts	0x0076, r30
//Дочерний протопоток, который отрабатывает ручной запуск
PT_THREAD(Sync(struct pt *pt))
{
	PT_BEGIN(pt);
	//PT_SEM_SIGNAL(pt, &manual_pulse); //устанавливает 1 в manual_pulse, сигнализируя что кнопки больше не опрашивались в другом пропотоке
	OUT_OFF; //устанавливаем 0 на выходе
 360:	c3 98       	cbi	0x18, 3	; 24
	if (!(BUT0_PORT_PIN&(_BV(BUT0))))//((BUT0_PORT_PIN&(_BV(BUT0)))==0)
 362:	86 99       	sbic	0x10, 6	; 16
 364:	11 c0       	rjmp	.+34     	; 0x388 <__stack+0x2a9>
	{
		LED0_ON;
 366:	93 9a       	sbi	0x12, 3	; 18
		OUT_ON; //устанавливаем 1 на выходе
 368:	c3 9a       	sbi	0x18, 3	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 36a:	bd e0       	ldi	r27, 0x0D	; 13
 36c:	ba 95       	dec	r27
 36e:	f1 f7       	brne	.-4      	; 0x36c <__stack+0x28d>
 370:	00 00       	nop
		_delay_us(5); //держим 1 на пине 80 микросекунд
		OUT_OFF; //сбрасываем выход в 0
 372:	c3 98       	cbi	0x18, 3	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 374:	8f ef       	ldi	r24, 0xFF	; 255
 376:	94 e3       	ldi	r25, 0x34	; 52
 378:	ac e0       	ldi	r26, 0x0C	; 12
 37a:	81 50       	subi	r24, 0x01	; 1
 37c:	90 40       	sbci	r25, 0x00	; 0
 37e:	a0 40       	sbci	r26, 0x00	; 0
 380:	e1 f7       	brne	.-8      	; 0x37a <__stack+0x29b>
 382:	00 c0       	rjmp	.+0      	; 0x384 <__stack+0x2a5>
 384:	00 00       	nop
		_delay_ms(500); //задержка перед следующим срабатыванием
		LED0_OFF;
 386:	93 98       	cbi	0x12, 3	; 18
	}
	PT_EXIT(pt);
	PT_END(pt);
 388:	10 92 73 00 	sts	0x0073, r1
 38c:	10 92 72 00 	sts	0x0072, r1
		//p_generator->regime=GEN_MANUAL; //на всякий пожарный, если режим генератора свалится в что-то неизвестное,
		//то попадет сюда и выставит ручной режим
		p_generator->state=GEN_ON;
		PT_SPAWN(pt, &Sync_pt, Sync(&Sync_pt));//вызываем дочерний протопоток ручного или синхро запуска
		//Макс частота нажатия кнопки ~2Гц
		LED0_OFF;
 390:	93 98       	cbi	0x12, 3	; 18
		LED1_OFF;
 392:	94 98       	cbi	0x12, 4	; 18
 394:	e8 ce       	rjmp	.-560    	; 0x166 <__stack+0x87>
/* Протопотоки */

//Дочерний протопоток, который отрабатывает ручной запуск
PT_THREAD(Sync(struct pt *pt))
{
	PT_BEGIN(pt);
 396:	80 91 72 00 	lds	r24, 0x0072
 39a:	90 91 73 00 	lds	r25, 0x0073
 39e:	89 2b       	or	r24, r25
 3a0:	99 f7       	brne	.-26     	; 0x388 <__stack+0x2a9>
 3a2:	de cf       	rjmp	.-68     	; 0x360 <__stack+0x281>
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-leds_timer)>=100);//запуск протопотока каждые 0.1мсек
	leds_timer=st_millis();
	if (p_generator->regime==GEN_PERIODIC)
	{
		switch(p_generator->period)
 3a4:	80 91 7d 00 	lds	r24, 0x007D
 3a8:	81 30       	cpi	r24, 0x01	; 1
 3aa:	09 f4       	brne	.+2      	; 0x3ae <__stack+0x2cf>
 3ac:	6c c0       	rjmp	.+216    	; 0x486 <__stack+0x3a7>
 3ae:	08 f4       	brcc	.+2      	; 0x3b2 <__stack+0x2d3>
 3b0:	5c c0       	rjmp	.+184    	; 0x46a <__stack+0x38b>
 3b2:	82 30       	cpi	r24, 0x02	; 2
 3b4:	09 f0       	breq	.+2      	; 0x3b8 <__stack+0x2d9>
 3b6:	e6 ce       	rjmp	.-564    	; 0x184 <__stack+0xa5>
				LED1_OFF;
				break;
			}
			case PERIOD_HZ1000: //LED0 горит непрерывно
			{
				LED0_ON;
 3b8:	93 9a       	sbi	0x12, 3	; 18
				LED1_OFF;
 3ba:	94 98       	cbi	0x12, 4	; 18
 3bc:	e3 ce       	rjmp	.-570    	; 0x184 <__stack+0xa5>
		if (p_generator->regime==GEN_MANUAL) 
		{
			p_generator->regime=GEN_PERIODIC;
			p_generator->period=PERIOD_HZ1; 
		} 
		else if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->period==PERIOD_HZ1))
 3be:	81 30       	cpi	r24, 0x01	; 1
 3c0:	09 f0       	breq	.+2      	; 0x3c4 <__stack+0x2e5>
 3c2:	2a cf       	rjmp	.-428    	; 0x218 <__stack+0x139>
 3c4:	90 91 7d 00 	lds	r25, 0x007D
 3c8:	91 11       	cpse	r25, r1
 3ca:	65 c0       	rjmp	.+202    	; 0x496 <__stack+0x3b7>
		{
			p_generator->period=PERIOD_HZ100;
 3cc:	80 93 7d 00 	sts	0x007D, r24
 3d0:	23 cf       	rjmp	.-442    	; 0x218 <__stack+0x139>
	{
		if (p_generator->duration==DURATION_US320) 
		{
			p_generator->duration=DURATION_50;
		}
		else if (p_generator->duration==DURATION_50)
 3d2:	81 30       	cpi	r24, 0x01	; 1
 3d4:	09 f4       	brne	.+2      	; 0x3d8 <__stack+0x2f9>
 3d6:	5c c0       	rjmp	.+184    	; 0x490 <__stack+0x3b1>
		{
			p_generator->duration=DURATION_90;
		}
		else
		{
			p_generator->duration=DURATION_US320;
 3d8:	10 92 7c 00 	sts	0x007C, r1
 3dc:	2a cf       	rjmp	.-428    	; 0x232 <__stack+0x153>
	//uint32_t dur=0;
	static volatile uint32_t switch_timer=0;
	PT_BEGIN(pt);
	PT_WAIT_UNTIL(pt,(st_millis()-switch_timer)>=10);//запуск протопотока каждые 10мсек
	switch_timer=st_millis();
	if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->state==GEN_OFF))
 3de:	80 91 7a 00 	lds	r24, 0x007A
 3e2:	81 11       	cpse	r24, r1
 3e4:	ad cf       	rjmp	.-166    	; 0x340 <__stack+0x261>
	{
		CLEAR_TCCR1B;
 3e6:	8e b5       	in	r24, 0x2e	; 46
 3e8:	88 7f       	andi	r24, 0xF8	; 248
 3ea:	8e bd       	out	0x2e, r24	; 46
		if (p_generator->period==PERIOD_HZ1000)
 3ec:	80 91 7d 00 	lds	r24, 0x007D
		{
			TCCR1B|=PRESCALER_1_MASK;
 3f0:	9e b5       	in	r25, 0x2e	; 46
	PT_WAIT_UNTIL(pt,(st_millis()-switch_timer)>=10);//запуск протопотока каждые 10мсек
	switch_timer=st_millis();
	if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->state==GEN_OFF))
	{
		CLEAR_TCCR1B;
		if (p_generator->period==PERIOD_HZ1000)
 3f2:	82 30       	cpi	r24, 0x02	; 2
 3f4:	09 f4       	brne	.+2      	; 0x3f8 <__stack+0x319>
 3f6:	8c c0       	rjmp	.+280    	; 0x510 <__stack+0x431>
		{
			TCCR1B|=PRESCALER_1_MASK;
			ICR1=PERIOD_HZ1000_TICKS;
		}
		else if (p_generator->period==PERIOD_HZ100)
 3f8:	81 30       	cpi	r24, 0x01	; 1
 3fa:	09 f4       	brne	.+2      	; 0x3fe <__stack+0x31f>
 3fc:	90 c0       	rjmp	.+288    	; 0x51e <__stack+0x43f>
			TCCR1B|=PRESCALER_8_MASK;
			ICR1=PERIOD_HZ100_TICKS;
		}
		else 
		{
			TCCR1B|=PRESCALER_256_MASK;
 3fe:	94 60       	ori	r25, 0x04	; 4
 400:	9e bd       	out	0x2e, r25	; 46
			ICR1=PERIOD_HZ1_TICKS;
 402:	15 bd       	out	0x25, r17	; 37
 404:	04 bd       	out	0x24, r16	; 36
		}
		if (p_generator->duration==DURATION_90)
 406:	90 91 7c 00 	lds	r25, 0x007C
 40a:	92 30       	cpi	r25, 0x02	; 2
 40c:	09 f4       	brne	.+2      	; 0x410 <__stack+0x331>
 40e:	60 c0       	rjmp	.+192    	; 0x4d0 <__stack+0x3f1>
		{
			OCR1=(uint16_t)((7*(uint32_t)ICR1)>>3);
		}
		else if (p_generator->duration==DURATION_50)
 410:	91 30       	cpi	r25, 0x01	; 1
 412:	09 f4       	brne	.+2      	; 0x416 <__stack+0x337>
 414:	a5 c0       	rjmp	.+330    	; 0x560 <__stack+0x481>
		{
			OCR1=(uint16_t)((uint32_t)ICR1>>1);
		}
		else
		{
			if (p_generator->period==PERIOD_HZ1000)
 416:	82 30       	cpi	r24, 0x02	; 2
 418:	09 f4       	brne	.+2      	; 0x41c <__stack+0x33d>
 41a:	86 c0       	rjmp	.+268    	; 0x528 <__stack+0x449>
			{
				OCR1=(uint16_t)(5*(uint32_t)ICR1>>4);
			}
			else if (p_generator->period==PERIOD_HZ100)
 41c:	81 30       	cpi	r24, 0x01	; 1
 41e:	09 f4       	brne	.+2      	; 0x422 <__stack+0x343>
 420:	a6 c0       	rjmp	.+332    	; 0x56e <__stack+0x48f>
			{
				OCR1=(uint16_t)((uint32_t)ICR1>>5);
			}
			else
			{
				OCR1=(uint16_t)(5*(uint32_t)ICR1>>14);
 422:	c4 b4       	in	r12, 0x24	; 36
 424:	d5 b4       	in	r13, 0x25	; 37
 426:	e1 2c       	mov	r14, r1
 428:	f1 2c       	mov	r15, r1
 42a:	26 01       	movw	r4, r12
 42c:	37 01       	movw	r6, r14
 42e:	44 0c       	add	r4, r4
 430:	55 1c       	adc	r5, r5
 432:	66 1c       	adc	r6, r6
 434:	77 1c       	adc	r7, r7
 436:	44 0c       	add	r4, r4
 438:	55 1c       	adc	r5, r5
 43a:	66 1c       	adc	r6, r6
 43c:	77 1c       	adc	r7, r7
 43e:	c4 0c       	add	r12, r4
 440:	d5 1c       	adc	r13, r5
 442:	e6 1c       	adc	r14, r6
 444:	f7 1c       	adc	r15, r7
 446:	9e e0       	ldi	r25, 0x0E	; 14
 448:	f6 94       	lsr	r15
 44a:	e7 94       	ror	r14
 44c:	d7 94       	ror	r13
 44e:	c7 94       	ror	r12
 450:	9a 95       	dec	r25
 452:	d1 f7       	brne	.-12     	; 0x448 <__stack+0x369>
 454:	db bc       	out	0x2b, r13	; 43
 456:	ca bc       	out	0x2a, r12	; 42
			}
		}
		p_generator->state=GEN_ON;
 458:	b0 92 7a 00 	sts	0x007A, r11
		CONNECT_TIMER_TO_PIN;//подключаем таймер к пину
 45c:	8f b5       	in	r24, 0x2f	; 47
 45e:	80 68       	ori	r24, 0x80	; 128
 460:	8f bd       	out	0x2f, r24	; 47
		GENERATOR_ON;
 462:	89 b7       	in	r24, 0x39	; 57
 464:	80 64       	ori	r24, 0x40	; 64
 466:	89 bf       	out	0x39, r24	; 57
 468:	7e ce       	rjmp	.-772    	; 0x166 <__stack+0x87>
	{
		switch(p_generator->period)
		{
			case PERIOD_HZ1:
			{
				if (counter1<10) //моргает LED0 раз в секунду
 46a:	80 91 61 00 	lds	r24, 0x0061
 46e:	8a 30       	cpi	r24, 0x0A	; 10
 470:	d8 f4       	brcc	.+54     	; 0x4a8 <__stack+0x3c9>
				{
					LED0_ON;
 472:	93 9a       	sbi	0x12, 3	; 18
					counter1++;
 474:	80 91 61 00 	lds	r24, 0x0061
 478:	8f 5f       	subi	r24, 0xFF	; 255
 47a:	80 93 61 00 	sts	0x0061, r24
					counter2=0;
 47e:	10 92 60 00 	sts	0x0060, r1
		}
	}
	else
	{
		LED0_OFF;
		LED1_OFF;	
 482:	94 98       	cbi	0x12, 4	; 18
 484:	7f ce       	rjmp	.-770    	; 0x184 <__stack+0xa5>
				LED1_OFF;
				break;
			}
			case PERIOD_HZ100: //моргает LED0 - 10 ращ в секунду
			{
				if (((LED0_PORT_PIN&(_BV(LED0)))==0))
 486:	83 99       	sbic	0x10, 3	; 16
 488:	16 cf       	rjmp	.-468    	; 0x2b6 <__stack+0x1d7>
				{
					LED0_ON;
 48a:	93 9a       	sbi	0x12, 3	; 18
		}
	}
	else
	{
		LED0_OFF;
		LED1_OFF;	
 48c:	94 98       	cbi	0x12, 4	; 18
 48e:	7a ce       	rjmp	.-780    	; 0x184 <__stack+0xa5>
		{
			p_generator->duration=DURATION_50;
		}
		else if (p_generator->duration==DURATION_50)
		{
			p_generator->duration=DURATION_90;
 490:	a0 92 7c 00 	sts	0x007C, r10
 494:	ce ce       	rjmp	.-612    	; 0x232 <__stack+0x153>
		} 
		else if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->period==PERIOD_HZ1))
		{
			p_generator->period=PERIOD_HZ100;
		}
		else if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->period==PERIOD_HZ100))
 496:	91 30       	cpi	r25, 0x01	; 1
 498:	09 f4       	brne	.+2      	; 0x49c <__stack+0x3bd>
 49a:	76 c0       	rjmp	.+236    	; 0x588 <__stack+0x4a9>
		{
			p_generator->period=PERIOD_HZ1000;
		}
		else if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->period==PERIOD_HZ1000))
 49c:	92 30       	cpi	r25, 0x02	; 2
 49e:	09 f0       	breq	.+2      	; 0x4a2 <__stack+0x3c3>
 4a0:	bb ce       	rjmp	.-650    	; 0x218 <__stack+0x139>
		{
			p_generator->regime=GEN_MANUAL;
 4a2:	10 92 7b 00 	sts	0x007B, r1
 4a6:	b8 ce       	rjmp	.-656    	; 0x218 <__stack+0x139>
				{
					LED0_ON;
					counter1++;
					counter2=0;
				}
				else if (counter2<10)
 4a8:	80 91 60 00 	lds	r24, 0x0060
 4ac:	8a 30       	cpi	r24, 0x0A	; 10
 4ae:	08 f0       	brcs	.+2      	; 0x4b2 <__stack+0x3d3>
 4b0:	03 cf       	rjmp	.-506    	; 0x2b8 <__stack+0x1d9>
				{
					LED0_OFF;
 4b2:	93 98       	cbi	0x12, 3	; 18
					counter2++;
 4b4:	80 91 60 00 	lds	r24, 0x0060
 4b8:	8f 5f       	subi	r24, 0xFF	; 255
 4ba:	80 93 60 00 	sts	0x0060, r24
					if (counter2>=9)
 4be:	80 91 60 00 	lds	r24, 0x0060
 4c2:	89 30       	cpi	r24, 0x09	; 9
 4c4:	08 f4       	brcc	.+2      	; 0x4c8 <__stack+0x3e9>
 4c6:	f8 ce       	rjmp	.-528    	; 0x2b8 <__stack+0x1d9>
					{
						counter1=0;
 4c8:	10 92 61 00 	sts	0x0061, r1
		}
	}
	else
	{
		LED0_OFF;
		LED1_OFF;	
 4cc:	94 98       	cbi	0x12, 4	; 18
 4ce:	5a ce       	rjmp	.-844    	; 0x184 <__stack+0xa5>
			TCCR1B|=PRESCALER_256_MASK;
			ICR1=PERIOD_HZ1_TICKS;
		}
		if (p_generator->duration==DURATION_90)
		{
			OCR1=(uint16_t)((7*(uint32_t)ICR1)>>3);
 4d0:	44 b4       	in	r4, 0x24	; 36
 4d2:	55 b4       	in	r5, 0x25	; 37
 4d4:	61 2c       	mov	r6, r1
 4d6:	71 2c       	mov	r7, r1
 4d8:	73 01       	movw	r14, r6
 4da:	62 01       	movw	r12, r4
 4dc:	cc 0c       	add	r12, r12
 4de:	dd 1c       	adc	r13, r13
 4e0:	ee 1c       	adc	r14, r14
 4e2:	ff 1c       	adc	r15, r15
 4e4:	cc 0c       	add	r12, r12
 4e6:	dd 1c       	adc	r13, r13
 4e8:	ee 1c       	adc	r14, r14
 4ea:	ff 1c       	adc	r15, r15
 4ec:	cc 0c       	add	r12, r12
 4ee:	dd 1c       	adc	r13, r13
 4f0:	ee 1c       	adc	r14, r14
 4f2:	ff 1c       	adc	r15, r15
 4f4:	c4 18       	sub	r12, r4
 4f6:	d5 08       	sbc	r13, r5
 4f8:	e6 08       	sbc	r14, r6
 4fa:	f7 08       	sbc	r15, r7
 4fc:	93 e0       	ldi	r25, 0x03	; 3
 4fe:	f6 94       	lsr	r15
 500:	e7 94       	ror	r14
 502:	d7 94       	ror	r13
 504:	c7 94       	ror	r12
 506:	9a 95       	dec	r25
 508:	d1 f7       	brne	.-12     	; 0x4fe <__stack+0x41f>
 50a:	db bc       	out	0x2b, r13	; 43
 50c:	ca bc       	out	0x2a, r12	; 42
 50e:	a4 cf       	rjmp	.-184    	; 0x458 <__stack+0x379>
	if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->state==GEN_OFF))
	{
		CLEAR_TCCR1B;
		if (p_generator->period==PERIOD_HZ1000)
		{
			TCCR1B|=PRESCALER_1_MASK;
 510:	91 60       	ori	r25, 0x01	; 1
 512:	9e bd       	out	0x2e, r25	; 46
			ICR1=PERIOD_HZ1000_TICKS;
 514:	a0 e4       	ldi	r26, 0x40	; 64
 516:	bf e1       	ldi	r27, 0x1F	; 31
 518:	b5 bd       	out	0x25, r27	; 37
 51a:	a4 bd       	out	0x24, r26	; 36
 51c:	74 cf       	rjmp	.-280    	; 0x406 <__stack+0x327>
		}
		else if (p_generator->period==PERIOD_HZ100)
		{
			TCCR1B|=PRESCALER_8_MASK;
 51e:	92 60       	ori	r25, 0x02	; 2
 520:	9e bd       	out	0x2e, r25	; 46
			ICR1=PERIOD_HZ100_TICKS;
 522:	d5 bd       	out	0x25, r29	; 37
 524:	c4 bd       	out	0x24, r28	; 36
 526:	6f cf       	rjmp	.-290    	; 0x406 <__stack+0x327>
		}
		else
		{
			if (p_generator->period==PERIOD_HZ1000)
			{
				OCR1=(uint16_t)(5*(uint32_t)ICR1>>4);
 528:	c4 b4       	in	r12, 0x24	; 36
 52a:	d5 b4       	in	r13, 0x25	; 37
 52c:	e1 2c       	mov	r14, r1
 52e:	f1 2c       	mov	r15, r1
 530:	26 01       	movw	r4, r12
 532:	37 01       	movw	r6, r14
 534:	44 0c       	add	r4, r4
 536:	55 1c       	adc	r5, r5
 538:	66 1c       	adc	r6, r6
 53a:	77 1c       	adc	r7, r7
 53c:	44 0c       	add	r4, r4
 53e:	55 1c       	adc	r5, r5
 540:	66 1c       	adc	r6, r6
 542:	77 1c       	adc	r7, r7
 544:	c4 0c       	add	r12, r4
 546:	d5 1c       	adc	r13, r5
 548:	e6 1c       	adc	r14, r6
 54a:	f7 1c       	adc	r15, r7
 54c:	84 e0       	ldi	r24, 0x04	; 4
 54e:	f6 94       	lsr	r15
 550:	e7 94       	ror	r14
 552:	d7 94       	ror	r13
 554:	c7 94       	ror	r12
 556:	8a 95       	dec	r24
 558:	d1 f7       	brne	.-12     	; 0x54e <__stack+0x46f>
 55a:	db bc       	out	0x2b, r13	; 43
 55c:	ca bc       	out	0x2a, r12	; 42
 55e:	7c cf       	rjmp	.-264    	; 0x458 <__stack+0x379>
		{
			OCR1=(uint16_t)((7*(uint32_t)ICR1)>>3);
		}
		else if (p_generator->duration==DURATION_50)
		{
			OCR1=(uint16_t)((uint32_t)ICR1>>1);
 560:	84 b5       	in	r24, 0x24	; 36
 562:	95 b5       	in	r25, 0x25	; 37
 564:	96 95       	lsr	r25
 566:	87 95       	ror	r24
 568:	9b bd       	out	0x2b, r25	; 43
 56a:	8a bd       	out	0x2a, r24	; 42
 56c:	75 cf       	rjmp	.-278    	; 0x458 <__stack+0x379>
			{
				OCR1=(uint16_t)(5*(uint32_t)ICR1>>4);
			}
			else if (p_generator->period==PERIOD_HZ100)
			{
				OCR1=(uint16_t)((uint32_t)ICR1>>5);
 56e:	84 b5       	in	r24, 0x24	; 36
 570:	95 b5       	in	r25, 0x25	; 37
 572:	96 95       	lsr	r25
 574:	87 95       	ror	r24
 576:	92 95       	swap	r25
 578:	82 95       	swap	r24
 57a:	8f 70       	andi	r24, 0x0F	; 15
 57c:	89 27       	eor	r24, r25
 57e:	9f 70       	andi	r25, 0x0F	; 15
 580:	89 27       	eor	r24, r25
 582:	9b bd       	out	0x2b, r25	; 43
 584:	8a bd       	out	0x2a, r24	; 42
 586:	68 cf       	rjmp	.-304    	; 0x458 <__stack+0x379>
		{
			p_generator->period=PERIOD_HZ100;
		}
		else if ((p_generator->regime==GEN_PERIODIC)&&(p_generator->period==PERIOD_HZ100))
		{
			p_generator->period=PERIOD_HZ1000;
 588:	a0 92 7d 00 	sts	0x007D, r10
 58c:	45 ce       	rjmp	.-886    	; 0x218 <__stack+0x139>

0000058e <_exit>:
 58e:	f8 94       	cli

00000590 <__stop_program>:
 590:	ff cf       	rjmp	.-2      	; 0x590 <__stop_program>
